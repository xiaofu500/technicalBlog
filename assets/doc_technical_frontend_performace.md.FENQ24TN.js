import{At as e,at as t,ct as n,s as r}from"./chunks/framework.DoL-8dLU.js";const i=JSON.parse(`{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc/technical/frontend/performace.md","filePath":"doc/technical/frontend/performace.md"}`);var a={name:`doc/technical/frontend/performace.md`};function o(r,i,a,o,s,c){return e(),n(`div`,null,[...i[0]||=[t(`p`,null,[t(`img`,{src:`/assets/image-BaObwY8o.png`,alt:`alt text`})],-1),t(`p`,null,`这种渲染机制在文档中，使用 canvas 来绘制内容，而不是直接在 DOM 中渲染。从而减少因大量 dom 创建所占的内存资源，dom 的 CURD 操作所占的 CPU 资源，降低浏览 GC 压力。 例如：千万行表格的渲染 可视区渲染：当前可见内容，为了防止白屏，上下域分别预渲染 n 行内容。 渲染区的内容：通过算法查找当前可见区域的行索引。 常见算法：`,-1),t(`ul`,null,[t(`li`,null,[t(`p`,null,`二分查找：将可见区域的起始行索引和结束行索引一分为二，根据当前滚动位置和行高，判断目标行在左半部分还是右半部分，递归查找。`)]),t(`li`,null,[t(`p`,null,`滑动窗口：维护一个固定大小的窗口，窗口内的行索引连续。当滚动位置改变时，根据滚动方向，将窗口滑动一位，更新窗口内的行索引。`)]),t(`li`,null,[t(`p`,null,`地图中类似的性能优化也是采用这种思路`)])],-1),t(`p`,null,`测试`,-1)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};