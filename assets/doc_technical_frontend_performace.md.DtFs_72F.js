import{ax as n,c as t,o as a,a as e}from"./chunks/framework.CFJOrnnk.js";const o="/technicalBlog/assets/image-BaObwY8o.png",f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc/technical/frontend/performace.md","filePath":"doc/technical/frontend/performace.md"}'),r={name:"doc/technical/frontend/performace.md"};function c(s,l,p,i,d,m){return a(),t("div",null,[...l[0]||(l[0]=[e("p",null,[e("img",{src:o,alt:"alt text"})],-1),e("p",null,"这种渲染机制在文档中，使用 canvas 来绘制内容，而不是直接在 DOM 中渲染。从而减少因大量 dom 创建所占的内存资源，dom 的 CURD 操作所占的 CPU 资源，降低浏览 GC 压力。 例如：千万行表格的渲染 可视区渲染：当前可见内容，为了防止白屏，上下域分别预渲染 n 行内容。 渲染区的内容：通过算法查找当前可见区域的行索引。 常见算法：",-1),e("ul",null,[e("li",null,[e("p",null,"二分查找：将可见区域的起始行索引和结束行索引一分为二，根据当前滚动位置和行高，判断目标行在左半部分还是右半部分，递归查找。")]),e("li",null,[e("p",null,"滑动窗口：维护一个固定大小的窗口，窗口内的行索引连续。当滚动位置改变时，根据滚动方向，将窗口滑动一位，更新窗口内的行索引。")]),e("li",null,[e("p",null,"地图中类似的性能优化也是采用这种思路")])],-1),e("p",null,"测试",-1)])])}const _=n(r,[["render",c]]);export{f as __pageData,_ as default};
